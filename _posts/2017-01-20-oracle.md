---
title: "An Aaronson Oracle"
date: 2017-01-20
layout: post
---
An *Aaronson oracle* is any computer program that asks a user to type sequences of symbols, such as `f` and `d`, and tries to predict what symbol the user will type next.
It is named after Scott Aaronson, who (as far as I know) first publicly described it. There is a demo of such an oracle online [here](http://people.ischool.berkeley.edu/~nick/aaronson-oracle/).
The motivation behind this oracle is to demonstrate that humans are generally very bad at acting randomly. This challenges the view that randomness is central to human free will, because if humans
suck at acting randomly, then either they don't posses free will or free will has little to do with randomness. The aim of this post is to formally describe an Aaronson oracle, since I have been
unable to find a clean presentation of the theory underlying it. The material presented here will reflect my understanding of the source code of the demo I linked to.

Let $$\Sigma$$ be the alphabet of symbols the user can choose from. Our job is to predict as accurately as we can the symbols the user will type. Let $$S_i$$ denote the $$i$$th symbol the user types,
then this is a discrete random variable taking values from $$\Sigma$$. The goal is to find the probability distribution $$\Pr(S_i)$$ of $$S_i$$ for each $$i$$. To do this, we will make a few assumptions:

1. $$\Pr(S_i)$$ is conditionally independent of all $$S_j$$ for $$j < i - c$$ for some constant $$c$$.
This basically means human working memory is limited: we assume that a user can only remember up to $$c$$ past symbols, so symbols before that have no influence on the current symbol.

2. $$\Pr(S_i \mid S_{i-c}, \dots, S_{i-1})$$ is the same for all $$i$$.
This boils down to the idea that people's behavior is predictable to some degree.

By these assumptions, it is reasonable to model the distribution of $$S_i$$ as a stationary Markov chain of order $$c$$.
The initial state of this chain, $$\Pr(S_1)$$, will represent our total initial ignorance of the user's behavior. Hence, it is the uniform distribution on $$\Sigma$$:
\begin{equation}
    \Pr(S_1 = s) = \frac{1}{|\Sigma|}.
\end{equation}
Then, as the user types more symbols, our algorithm should adjust the probabilities to better predict what the user will type next.
A plausible rule of thumb is the following:

>A user will tend to type the same patterns over and over again.

To model this, we might keep track of the frequencies of all $$c$$-grams (sequences of length $$c$$) the user has typed so far.
To predict what symbol the user will type next, we simply pick the next symbol of the most likely $$c$$-gram the user is currently typing.
This can be done efficiently in both time and space using a [trie](https://en.wikipedia.org/wiki/Trie) where the nodes are augmented to store the absolute frequencies
of the symbols in the current path. The depth of the trie is bounded by the order of the Markov chain. The algorithm conceptually works like this. First, it initializes
a new trie containing just an empty root node. The current node is set to the root node. Then, for every key the user presses, we first predict the symbol that has been typed
by randomly choosing one of the children of the current node, where the probability of a child being chosen is proportional to their frequency.
If the current node has no children, we return a uniform random choice from the alphabet.
The trie is then updated based on which of the following scenarios apply:

1. We are not yet at depth $$c$$ in the trie. In this case, the current path through the trie is extended with a new node labeled with the key the user pressed and an initial frequency of 1.
If the current node already had such a child node, its absolute count is simply incremented. We then set the current node to this child node.

2. We are at depth $$c$$. We then reset the current node to the root node.

Below you can find an implementation of this algorithm. Just type in the input box and watch the accuracy of the prediction evolve as you type.
To benchmark the performance of the algorithm, note that on actual uniform random input the accuracy is about 33%. You can verify this experimentally yourself if you want;
just go to [RANDOM.org](https://www.random.org/) or some equivalent site and use true random numbers to guide your decision. So 33% should be your target if you wish to
achieve the same accuracy as a random oracle. However, my own experiments (on myself, of course) have shown that the accuracy usually increases to well beyond 50% for human input.
The order of the chain was set to 5 in this implementation, so if you want to deliberately fool the algorithm, you can always try to construct sequences such that $$\Pr(S_i)$$ is
conditionally dependent on at least 6 previous characters.

<input id="oracle" style="width: 100%; font-size: 30px">

<div id="stats"></div>

<div id="results"></div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">
    // key codes for f and d
    F_KEY = 102;
    D_KEY = 100;
    // order of the chain
    ORDER = 5;
    // number of correct and wrong guesses
    correct = 0;
    wrong = 0;

    /**
    * Node in the trie.
    * s: symbol of the node
    * d: depth of the node
    **/
    function Node(s, d) {
        // store symbol
        this.label = s;
        // store edges to children
        this.edges = [];
        // store absolute frequency
        this.count = 1;
        // store depth
        this.depth = d;

        // add an edge
        this.addEdge = function(symbol) {
            // if this edge exists already
            if(symbol in this.edges) {
                // increment count
                this.edges[symbol].count++;
            }else{
                // otherwise create new child
                this.edges[symbol] = new Node(symbol, this.depth + 1);
            }

            return this.edges[symbol];
        };

        // predict next symbol
        this.predict = function() {
            // return one of the children with probability proportional to frequency
            var q = Math.random();
            var total = 0;
            for(edge in this.edges) {
                total += this.edges[edge].count;
            }
            for(edge in this.edges) {
                if(this.edges[edge].count / total >= q) {
                    return this.edges[edge].label;
                }
            }

            // otherwise return uniform random guess
            return Math.random() <= 0.5 ? "f" : "d";
        }
    }

    // handle key presses
    $("#oracle").keypress(function(event) {
        // if key was f or d
        if(event.which == F_KEY || event.which == D_KEY) {
            // predict this key
            var prediction = current.predict();

            // update trie
            var key = (event.which == F_KEY) ? "f" : "d";
            current = current.addEdge(key);
            
            // restart from root if necessary
            if(current.depth >= ORDER) {
                current = trie;
            }

            // update stats
            color = (key === prediction) ? "black" : "red";
            $("#results").prepend("<p style='color: " + color + "'>actual: " + key + "; predicted: " + prediction + "</p>");
            if(key === prediction) {
                correct++;
            }else{
                wrong++;
            }
            acc = Math.round(100 * correct / (correct + wrong));
            $("#stats").text("accuracy: " + acc + "%");
        }

        $("#oracle").val("");
    })

    // initialize
    trie = new Node('', 0);
    current = trie;
</script>