---
title: "An Aaronson Oracle"
date: 2017-01-20
layout: post
---
An *Aaronson oracle* is any computer program that asks a user to type sequences of symbols, such as `f` and `d`, and tries to predict what symbol the user will type next.
It is named after Scott Aaronson, who (as far as I know) first publicly described it. There is a demo of such an oracle online [here](http://people.ischool.berkeley.edu/~nick/aaronson-oracle/).
The motivation behind this oracle is to demonstrate that humans are generally very bad at acting randomly. This challenges the view that randomness is central to human free will, because if humans
suck at acting randomly, then either they don't posses free will or free will has little to do with randomness. The aim of this post is to formally describe an Aaronson oracle, since I have been
unable to find a clean presentation of the theory underlying it. The material presented here will reflect my understanding of the source code of the demo I linked to.

Let $$\Sigma$$ be the alphabet of symbols the user can choose from. Our job is to predict as accurately as we can the symbols the user will type. Let $$S_i$$ denote the $$i$$th symbol the user types,
then this is a discrete random variable taking values from $$\Sigma$$. The goal is to find the probability distribution $$\Pr(S_i)$$ of $$S_i$$ for each $$i$$. To do this, we will make a few assumptions:

1. $$\Pr(S_i)$$ is conditionally independent of all $$S_j$$ for $$j < i - c$$ for some constant $$c$$.
This basically means human working memory is limited: we assume that a user can only remember up to $$c$$ past symbols, so symbols before that have no influence on the current symbol.

2. $$\Pr(S_i \mid S_{i-c}, \dots, S_{i-1})$$ is the same for all $$i$$.
This boils down to the idea that people's behavior is predictable to some degree.

By these assumptions, it is reasonable to model the distribution of $$S_i$$ as a stationary Markov chain of order $$c$$.
The initial state of this chain, $$\Pr(S_1)$$, will represent our total initial ignorance of the user's behavior. Hence, it is the uniform distribution on $$\Sigma$$:
\begin{equation}
    \Pr(S_1 = s) = \frac{1}{|\Sigma|}.
\end{equation}
Then, as the user types more symbols, our algorithm should adjust the probabilities to better predict what the user will type next.
A plausible rule of thumb is the following:

>A user will tend to type the same patterns over and over again.

To model this, we might keep track of the frequencies of all $$c$$-grams (sequences of length $$c$$) the user has typed so far.
To predict what symbol the user will type next, we simply pick the next symbol of the most likely $$c$$-gram the user is currently typing.
This can be done efficiently in both time and space using a [trie](https://en.wikipedia.org/wiki/Trie) where the nodes are augmented to store the absolute frequencies
of the symbols in the current path. The depth of the trie is bounded by the order of the Markov chain. The algorithm conceptually works like this. First, it initializes
a new trie containing just an empty root node. The current node is set to the root node. Then, for every key the user presses, we first predict the symbol that has been typed
by simply finding the child node of the current node with the highest frequency. If the current node has no children, we return a uniform random choice from the alphabet.
The trie is then updated based on which of the following scenarios apply:

1. We are not yet at depth $$c$$ in the trie. In this case, the current path through the trie is extended with a new node labeled with the key the user pressed and an initial frequency of 1.
If the current node already had such a child node, its absolute count is simply incremented. We then set the current node to this child node.

2. We are at depth $$c$$. We then take the last $$c-1$$ characters the user typed and follow this path through the trie, adding new nodes and incrementing frequencies where necessary.
The current node is set to the node at the end of this path.

Below you can find an implementation of this algorithm. Just type in the input box and watch the accuracy of the prediction evolve as you type.

<input id="oracle" style="width: 100%; font-size: 30px">

<div id="stats"></div>

<div id="results"></div>

<script type="text/javascript">
    F_KEY = 102;
    D_KEY = 100;
    ORDER = 5;
    correct = 0;
    wrong = 0;
    gram = [];

    function Node(s, d) {
        this.label = s;
        this.edges = [];
        this.count = 1;
        this.depth = d;
        this.addEdge = function(symbol) {
            if(symbol in this.edges) {
                this.edges[symbol].count++;
            }else{
                this.edges[symbol] = new Node(symbol, this.depth + 1);
            }

            return this.edges[symbol];
        };
        this.predict = function() {
            if(this.edges.length == 0) {
                return Math.random() <= 0.5 ? "f" : "d";
            }

            var prediction = undefined;
            for(edge in this.edges) {
                node = this.edges[edge];
                if(prediction === undefined || prediction.count < node.count) {
                    prediction = node;
                }
            }

            return prediction.label;
        }
        this.find = function(path) {
            if(this.depth >= path.length) {
                return this;
            }

            var c = path[this.depth];
            if(c in this.edges) {
                return this.edges[c].find(path);
            }

            this.edges[c] = new Node(c, this.depth + 1);
            return this.edges[c].find(path);
        }
    }

    $("#oracle").keypress(function(event) {
        if(event.which == F_KEY || event.which == D_KEY) {
            var prediction = current.predict();
            var key = (event.which == F_KEY) ? "f" : "d";
            current = current.addEdge(key);
            gram.push(key);
            if(current.depth >= ORDER) {
                gram.shift();
                current = trie.find(gram);
                gram = [];
            }

            color = (key === prediction) ? "black" : "red";
            $("#results").prepend("<p style='color: " + color + "'>actual: " + key + "; predicted: " + prediction + "</p>");
            if(key === prediction) {
                correct++;
            }else{
                wrong++;
            }
            acc = Math.round(100 * correct / (correct + wrong));
            $("#stats").text("accuracy: " + acc + "%");
        }

        $("#oracle").val("");
    })

    trie = new Node('', 0);
    current = trie;
</script>