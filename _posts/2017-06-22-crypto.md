---
title: Overview of Asymmetric Cryptography
layout: post
date: 2017-06-22
tags: infosec
---
The asymmetric cryptosystems used in practice fall roughly into two categories:

1. Cryptosystems based on hardness of factoring.
2. Cryptosystems based on hardness of the discrete logarithm problem.

In this post, I will attempt to provide an overview of how these systems work at a high level.
I will cover how encryption and decryption is done in each of these systems as well as how to
generate and verify their digital signatures.

# Factoring

The *factoring problem* is the problem of determining non-trivial factors of a given integer $$N$$.
The *factoring assumption* is the assumption that factoring is hard relative to some method of generating composite integers $$N$$.
Formally, we define the *factoring experiment* as follows. Given an algorithm $$\mathcal{G}$$ for generating $$n$$-bit primes and
an adversary $$\mathcal{A}$$:

1. Run $$\mathcal{G}(n)$$ to obtain two $$n$$-bit primes $$p$$ and $$q$$.
2. Compute $$N = pq$$.
3. Give $$N$$ to the adversary $$\mathcal{A}$$. The adversary outputs integers $$p^\prime, q^\prime$$.
4. The experiment succeeds if $$p^\prime, q^\prime$$ are non-trivial factors of $$N$$, i.e. $$p^\prime, q^\prime > 1$$ and $$N = p^\prime q^\prime$$.

The factoring assumption states that there exists an efficient algorithm $$\mathcal{G}$$ such that for any efficient adversary $$\mathcal{A}$$,
the factoring experiment relative to $$\mathcal{G}$$ and $$\mathcal{A}$$ can only succeed with negligible probability.

## RSA

The best known cryptosystem based on hardness of factoring is *RSA*, named after its authors Rivest, Shamir and Adleman.

**Key generation**. To generate a pair of RSA keys $$(pk, sk)$$, we perform the following operations:

1. Generate two $$n$$-bit primes $$p$$ and $$q$$. Compute $$N = pq$$, $$\varphi(N) = (p-1)(q-1)$$.
2. Compute $$e > 1$$ such that $$\gcd(e,\varphi(N)) = 1$$ and $$d$$ such that $$ed \equiv 1 \mod \varphi(N)$$.
3. The public key is $$(N,e)$$; the private key is $$(p,q,d)$$.

**Encryption**. To encrypt a plaintext message $$m \in \mathbb{Z}_N^\star$$, we compute the ciphertext $$c$$ as

$$
    c \equiv m^e \mod N.
$$

**Decryption**. To decrypt a ciphertext $$c \in \mathbb{Z}_N^\star$$, compute

$$
    m \equiv c^d \mod N.
$$

**Signature generation**. An RSA signature $$\sigma$$ on a message $$m$$ is computed as

$$
    \sigma \equiv m^d \mod N.
$$

**Signature verification**. To verify a signature $$\sigma$$ on a message $$m$$, check that

$$
    m \equiv \sigma^e \mod N.
$$

**Correctness**. Correctness of both encryption/decryption and signing/verifying is easily checked by noting that, by Euler's theorem, we have

$$
    c^d \equiv (m^e)^d \equiv m^{ed} \equiv m^{k\varphi(N) + 1} \equiv m \mod N.
$$

# Discrete logarithm

The *discrete logarithm problem* is the problem of computing $$\log_g(g^x)$$ in a cyclic group $$(\mathbb{G}, q, g)$$.
That is, we are given a group with elements $$\mathbb{G}$$, order $$q$$ and generator $$g$$.
We are then asked to compute $$x$$ given a group element $$g^x$$.
This problem is assumed to be hard relative to some algorithm for generating cyclic groups, in particular prime-order
subgroups of $$\mathbb{Z}_p^\star$$ as well as elliptic curve groups.

## ElGamal

The most prominent asymmetric cryptosystem based on the discrete logarithm problem is *ElGamal*, named after its author
Taher ElGamal. The description given here, however, is a generalised version of this algorithm which works with any group,
whereas the original formulation of ElGamal was specialized for prime-order subgroups of $$\mathbb{Z}_p^\star$$.

The digital signature scheme presented here is also called the *Digital Signature Algorithm* (DSA).
Again, the description of this algorithm in this post is generalised to arbitrary groups and so also covers the case where
the group is an elliptic curve. The specialized version for elliptic curves is called the *Elliptic Curve Digital Signature Algorithm* (ECDSA).

**Key generation**. The public and private keys are determined as follows:

1. Generate a cyclic group $$(\mathbb{G}, q, g)$$ with an $$n$$-bit order $$q$$.
2. Choose a uniform random element $$x \in \mathbb{Z}_q$$ and compute $$y = g^x$$.
3. The public key is $$(\mathbb{G}, q, g, y)$$; the private key is $$(\mathbb{G}, q, g, x)$$.

**Encryption**. To encrypt a plaintext message $$m \in \mathbb{G}$$:

1. Choose a uniform random element $$k \in \mathbb{Z}_q$$ and compute $$z = g^k$$.
2. Compute $$s = my^k$$.
3. The ciphertext is the pair $$(z, s)$$.

**Decryption**. To decrypt a ciphertext $$(z, s)$$, we compute

$$
    m = s(z^x)^{-1}.
$$

**Signature generation**. To sign a message $$m$$:

1. Generate a uniform random element $$k \in \mathbb{Z}_q^\star$$ and compute $$r = g^k$$.
2. Compute $$s = k^{-1}(H(m) + xr) \mod q$$ where $$H$$ is a cryptographic hash function.
3. The signature is the pair $$(r, s)$$.

**Signature verification**. To verify a signature $$(r,s)$$ on a message $$m$$, check that

$$
    r = g^{H(m)s^{-1}}y^{rs^{-1}}.
$$

**Correctness**. To see that encryption and decryption are correct, we check

$$
    s(z^x)^{-1} = my^k\left( g^{xk} \right)^{-1} = mg^{xk}g^{-xk} = m.
$$

To verify the digital signatures:

$$\begin{aligned}
    g^{H(m)s^{-1}}y^{rs^{-1}} &= g^{H(m)s^{-1}}g^{xrs^{-1}}\\
        &= g^{H(m)s^{-1} + xrs^{-1}}\\
        &= g^{(H(m) + xr)s^{-1}}\\
        &= g^{(H(m) + xr)(H(m) + xr)^{-1}k}\\
        &= g^k\\
        &= r.
\end{aligned}$$
